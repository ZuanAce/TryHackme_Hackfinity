# Crypto System 

## Challenge Description
> ![image](https://github.com/user-attachments/assets/b93f41e2-72b5-4c0d-bdc3-2163627fca9e)

## Solution
The provided RSA implementation follows these key steps:
1. Generates a 1024-bit prime p.
2. Computes q as the next prime after p.
3. Calculates n = p * q.
4. Uses a common public exponent e = 0x10001.
5. Computes the private exponent d = inverse(e, (p-1)*(q-1)).
6. Encrypts the flag using c = pow(FLAG, e, n).

The challenge involves recovering p, q, and d to decrypt the flag.

Since `q` is simply the next prime after `p`, we can approximate `p` by taking the square root of `n`. We then step backwards to the previous prime and calculate `q` as `n // p`.

### Code for prime recovery
```python
from Crypto.Util.number import isPrime, inverse
from math import isqrt

def primo(n, reverse=False):
    step = -2 if reverse else 2
    n += step if n & 1 else step - 1
    while not isPrime(n):
        n += step
    return n

def recover_secret_key(n, e):
    p = isqrt(n)  # Approximate square root of n
    p = primo(p, reverse=True)  # Find the previous prime
    q = n // p  # Compute q
    assert p * q == n  # Ensure correctness

    phi = (p - 1) * (q - 1)
    d = inverse(e, phi)  # Compute modular inverse of e
    return p, q, d

# Given values
n = 15956250162063169819282947443743274370048643274416742655348817823973383829364700573954709256391245826513107784713930378963551647706777479778285473302665664446406061485616884195924631582130633137574953293367927991283669562895956699807156958071540818023122362163066253240925121801013767660074748021238790391454429710804497432783852601549399523002968004989537717283440868312648042676103745061431799927120153523260328285953425136675794192604406865878795209326998767174918642599709728617452705492122243853548109914399185369813289827342294084203933615645390728890698153490318636544474714700796569746488209438597446475170891
e = 0x10001

# Recover p, q, and d
p, q, d = recover_secret_key(n, e)

print(f"p: {p}")
print(f"q: {q}")
print(f"d: {d}")
```

Once we have `d`, we can decrypt the flag by computing `m = c^d mod n`.

## Code for decryption
```python
from Crypto.Util.number import long_to_bytes

d = 7235421858128893307436267026765989101257390189192620324879932985837634018051790159097701293642294329498093247266865785770462912042815709355800352405642892045993794882731320697231917868650657728953910950643271496177244794087950946867709698032715107954455503894929626223565509096884617045670405445705088314284072116605469833626716605776636105451319294526990691690036758888137240405858458410668186219614389144884307450327584189358883234991436587301726548777684364228959489868297699572567319165255948974377098534343089744996814930139330755308656119243647852012950022369435604068121493577055881369923400669736277596521649
c = 3591116664311986976882299385598135447435246460706500887241769555088416359682787844532414943573794993699976035504884662834956846849863199643104254423886040489307177240200877443325036469020737734735252009890203860703565467027494906178455257487560902599823364571072627673274663460167258994444999732164163413069705603918912918029341906731249618390560631294516460072060282096338188363218018310558256333502075481132593474784272529318141983016684762611853350058135420177436511646593703541994904632405891675848987355444490338162636360806437862679321612136147437578799696630631933277767263530526354532898655937702383789647510
n = 15956250162063169819282947443743274370048643274416742655348817823973383829364700573954709256391245826513107784713930378963551647706777479778285473302665664446406061485616884195924631582130633137574953293367927991283669562895956699807156958071540818023122362163066253240925121801013767660074748021238790391454429710804497432783852601549399523002968004989537717283440868312648042676103745061431799927120153523260328285953425136675794192604406865878795209326998767174918642599709728617452705492122243853548109914399185369813289827342294084203933615645390728890698153490318636544474714700796569746488209438597446475170891

decrypted_flag = long_to_bytes(pow(c, d, n))
print("FLAG:", decrypted_flag.decode())
```

Running the script reveals the flag: `THM{Just_s0m3_small_amount_of_RSA!}`

## Flag: 
THM{Just_s0m3_small_amount_of_RSA!}



   
